desc: Surround upscale ALPHA
//tags: requested by James HE , modded by geraintluff, modded by junh1024,
//via https://forum.cockos.com/showpost.php?p=1962348&postcount=18

// TODO: performance improvements like moving FFT stuff to @block, frequency selection, half fft for center?

slider1:0<0,100,2>Width
slider2:0<-100,100,1>Depth
slider3:90<0,180,2>Rear threshold
slider4:90<0,180,2>Crossover width
slider5:80<0,100,2>Rear Width
slider6:50<0,100,1>Rear LP
slider7:50<0,100,2>Rear transients
slider8:2<0,4,1{1024 (high artefacts) ,2048,4096 (medium artefacts),8192 (low artefacts)}>FFT Size

import surroundlib2.txt
import surroundlib3.txt

@init 

fftsize = -1;
pdc_bot_ch = 0;
pdc_top_ch = 6;

// array pointers
window=0;

sixteen_k=16384;

buf0 = sixteen_k*1;
buf1 = sixteen_k*2;

buf2 = sixteen_k*3;
buf3 = sixteen_k*4;

buf4 = sixteen_k*5;
buf5 = sixteen_k*6;

Magnitudes1=sixteen_k*11;
Magnitudes2=sixteen_k*12;
Magnitudes3=sixteen_k*13;
// Magnitudes4=sixteen_k*14;
// Magnitudes5=sixteen_k*15;
// Magnitudes6=sixteen_k*16;

Magnitudes1_old=sixteen_k*41;
Magnitudes2_old=sixteen_k*42;
memset(Magnitudes1_old, 0, sixteen_k);

Angles1=sixteen_k*21;
Angles2=sixteen_k*22;
Angles3=sixteen_k*23;
// Angles4=sixteen_k*24;
// Angles5=sixteen_k*25;
// Angles6=sixteen_k*26;

Sideness=sixteen_k*31;
Sideness_old=sixteen_k*32;

Angle_Difference=sixteen_k*41;
Angle_Difference_old=sixteen_k*42;
// Pan_Array=sixteen_k*32;

Rear_threshold=0;
Crossover_width=0;

gfx_r = gfx_g = gfx_b = 1;

exceeded=0;

center_phase_level=center_mag_level=0;

pi=3.141592653589793238;
h_pi=pi/2;
h_sqrt_2=0.7071067811865475;

pos=0;
pos2=0;

	mid_r  = mid_i  = 0;
	side_r = side_i = 0;
	
	mid = side = 0;
	
	// Sideness[i]=0;
	
	center_r = center_i = 0;

	
	
	an1=an2=0;
	
left_r = left_i = right_r= right_i= 0;
left_r_two = left_i_two = right_r_two= right_i_two= 0;

//phase, transient scaling
P_scaling=T_scaling=0;
tmp=a=b=a2=b2=0;

	memset(buf0, 0, 2*fftsize);
	memset(buf1, 0, 2*fftsize);
	memset(buf2, 0, 2*fftsize);
	memset(buf3, 0, 2*fftsize);
	memset(Angle_Difference, 0, 2*fftsize);
	memset(Angle_Difference_old, 0, 2*fftsize);
	memset(Sideness, 0, 2*fftsize);
	memset(Sideness_old, 0, 2*fftsize);
	
	R_width_coeff=0;
	depth2=0;
	doing=0;
	
	
	cutoff=0;
	cutoff_bins=0;
inspector1=0;
inspector2=0;

Fixed_Response=0.5;

@slider

sliderfft = (2^(slider8+10))|0;
fftsize != sliderfft ?
(
	pos = 0;
	memset(buf0, 0, 2*fftsize);
	memset(buf1, 0, 2*fftsize);
	memset(buf2, 0, 2*fftsize);
	memset(buf3, 0, 2*fftsize);
	// memset(buf4, 0, 2*fftsize);
	// memset(buf5, 0, 2*fftsize);
	memset(window, 0, fftsize);
	fftsize = sliderfft;
	w = 2.0*$pi/fftsize;
	i = 0;
	
	loop(fftsize/2,
		window[i] = 0.42-0.50*cos(i*w)+0.08*cos(2.0*i*w); //blackman window
		// window[i] =1- (1-abs(i/fftsize)); //triangle window
		// window[i] =min(2- (2-abs(i/fftsize)),1); //trapezium window
		// window[i] = 0.5;
		i += 1;
	); 
	pdc_delay = fftsize;
);

Rear_threshold= slider3*pi/180;
Crossover_width=max(slider4*pi/180,0.1);//min of 0.1 since don't want an infinite slope/div 0
width_coeff=slider1/100; 

depth_coeff=(slider2*$pi)/200; //depth scaled from 0-100 to 0>half pi
calculate_depth_coeffs(depth_coeff);
R_width_coeff=slider5/100;
depth2=abs(slider2);

cutoff=slider6/100;
cutoff_bins=floor(cutoff*(fftsize));
transient_amount=slider7/100;


@sample

pos >= fftsize ?
(
	tmp = buf0;
	buf0 = buf1;
	buf1 = tmp;

	tmp = buf2;
	buf2 = buf3;
	buf3 = tmp;
	
	// tmp = buf4;
	// buf5 = buf5;
	// buf4 = tmp;

	fft(buf0, fftsize);
	fft_permute(buf0, fftsize);

	// fft(buf2, fftsize);
	// fft_permute(buf2, fftsize);

	i = 2;
	loop(fftsize/2 - 1, 
		
		//loop indexes
		a = i;
		b = a+1;
		a2 = 2*fftsize-i;
		b2 = a2+1;


		x = buf0[a];
		y = buf0[b];
		x2 = buf0[a2];
		y2 = buf0[b2];

		 left_r = left_r_two =(x + x2)*0.5;
		 left_i = left_i_two =(y - y2)*0.5;
		right_r = right_r_two=(y + y2)*0.5;
		right_i = right_i_two=(x2 - x)*0.5;



		//completely rewritten in Complex instead of Polar for more performance & no fiddly phase compensation

		//convert to M/S, center content
		
		
		// inspector1=fftsize-ceil((fftsize-cutoff_bins)/2);
		
		width_coeff<1?
		// width_coeff<1&&i<fftsize-ceil((fftsize-cutoff_bins)/1.5)?
		(
		mid_r  = (left_r+right_r);
		mid_i  = (left_i+right_i);
		side_r = (left_r-right_r);
		side_i = (left_i-right_i);
		
		//measure the magnitude of M&S, to decide how much should go in C/S
		
		mid=sqrt(mid_r^2+mid_i^2);
		side=sqrt(side_r^2+side_i^2);
		
		// sd=s/m+s or m-s/m+s
		
		Sideness[i]=min(side/mid,1); //clamp Sideness[i] to 1
		
		Sideness[i]=Sideness[i]*(Fixed_Response)+Sideness_old[i]*(1-Fixed_Response);
		Sideness_old[i]=Sideness[i];
		
		//0.7 3dB correction
		center_r = mid_r *(1-Sideness[i])*h_sqrt_2;
		center_i = mid_i *(1-Sideness[i])*h_sqrt_2;
		
		// Sideness[i]=1;
	

		
		
		//M/S decode LR
		left_r =  (mid_r*0.5*Sideness[i]) + (side_r*0.5);
		left_i =  (mid_i*0.5*Sideness[i]) + (side_i*0.5);
		right_r = (mid_r*0.5*Sideness[i]) - (side_r*0.5);
		right_i = (mid_i*0.5*Sideness[i]) - (side_i*0.5);	
		
		
		);
		// :(center_r=center_i=0;);

		

		(i<cutoff_bins && abs(slider2)<100)? //rear lowpass		
		// (depth2<=99)? //activate only as needed
		(
		Angles1[i]=an1=atan2(left_r_two,left_i_two); //radians, normalize to 0,2pi
		Angles2[i]=an2=atan2(right_r_two,right_i_two);	
		Angle_Difference[i]=abs(an1-an2);	

		// ad=Angle_Difference[i];
		Angle_Difference[i]>pi?Angle_Difference[i]=2*pi-Angle_Difference[i];//fix angle difference cuz should be under 180*
		
		Angle_Difference[i]=Angle_Difference[i]*(Fixed_Response)+Angle_Difference_old[i]*(1-Fixed_Response);
		Angle_Difference_old[i]=Angle_Difference[i];
		
		T_scaling=1;
		
		Magnitudes1[i]=(left_r^2+left_i^2);// only analysing L for transient & no sqrt cuz it's faster
		//remove transients from top half of rear, copied from FFT Multi Tool
		((i>cutoff_bins/2) && (Magnitudes1[i]>Magnitudes1_old[i]))?
		(
			T_scaling=((Magnitudes1[i]*(transient_amount^2)+Magnitudes1_old[i]*(1-(transient_amount^2)))/Magnitudes1[i]);
		);
		
		
		//remove from front if wide, but scale it according to how transient it is, so transients get rmv from rear when subtraction happens later.
		
		// P_scaling=1-((Angle_Difference[i]/pi)*T_scaling);
		// P_scaling=1-((Angle_Difference[i]/pi));
		// P_scaling=min(max(1-((((Angle_Difference[i])+Rear_threshold)/pi)*T_scaling),0),1); 
		// P_scaling=min(max(1-(   (  ((+-h_pi)/(Crossover_width/pi))+h_pi  )    *T_scaling ) ,0)     ,1) ; 
// front_coefficient_temp= 1 - ((phadeg- low_thresh )* (1.0/crossover_width))



		P_scaling= min(max( ( 1-(Angle_Difference[i]-Rear_threshold+(Crossover_width/2))*T_scaling*(1/Crossover_width) )   ,0)     ,1)  ;
		
		// P_scaling=1;
		// P_scaling*=T_scaling;
		// P_scaling=1;
		// Angle_Difference[i]>Rear_threshold?(P_scaling=0);
		
		 left_r*=P_scaling;
		 left_i*=P_scaling;
		right_r*=P_scaling;
		right_i*=P_scaling;
		// doing=1;
		Magnitudes1_old[i]=Magnitudes1[i];
		
		);
		
		
		//BUG: upscales to rear when 100% hard panned
		
		// ad=slider4*$pi/180;
/*
		//from -1 to 1, L to R.
		pan=(Magnitudes2[i]-Magnitudes1[i])/(Magnitudes2[i]+Magnitudes1[i]);

		center_phase_level= 1-min(2*ad/pi,1);;//double ad & clamp to +0, to make C selection 90* wide instead of 180

		//reduce C if the depending on pan & phase
		center_mag_level=(1-abs(pan))*center_phase_level;
		
		// center_mag_level=0;
		
		
		// center_mag_level=(1-abs(pan));
		// ad>$pi/10?center_mag_level=0;//remove from C if angle >9*

		//move to center if centered
		Magnitudes3[i]=center_mag_level*(Magnitudes1[i]+Magnitudes2[i])*0.7071;
		Magnitudes1[i]*=1-center_mag_level;
		Magnitudes2[i]*=1-center_mag_level;
		
		Angles3[i]    =(Angles1[i]+Angles2[i])/2;  //averaging angle sounds bad?
		// Angles3[i]    =Angles1[i]; //prolly wrong, but sounds bad if i add A1 & A2. But LR will be adjusted after this to partially compensate

		//rear stuff
		
		// (Angle_Difference[i]>Rear_threshold-Crossover_width&&Angle_Difference[i]<Rear_threshold+Crossover_width)?
		// (
			// dummy=1;
		// )
		// :
		// (
			// (Angle_Difference[i]>Rear_threshold)?
			// Magnitudes1[i]=Magnitudes2[i]=0;
		
		// );


*/

		//more voodoo
		buf0[a]  = left_r - right_i;
		buf0[b]  = left_i + right_r;
		buf0[a2] = left_r + right_i;
		buf0[b2] = right_r - left_i;

		//prepare c

		buf2[a] = center_r;
		buf2[b] = center_i;
		buf2[a2]= center_r;
		buf2[b2]=-center_i;
		
		i += 2
	);

	fft_ipermute(buf0, fftsize);
	ifft(buf0, fftsize);
	
	// width_coeff<1?(
	fft_ipermute(buf2, fftsize);
	ifft(buf2, fftsize);
// );
	pos=0;
);

//windowing?
w1 = window[pos/2];
w2 = window[(fftsize-pos)/2-1];
sw = (w1+w2)*fftsize;

out0 = (buf0[pos]+buf1[fftsize+pos])/sw;
out1 = (buf0[pos+1]+buf1[fftsize+pos+1])/sw;
out2 = (buf2[pos]+buf3[fftsize+pos])/sw;
// out3 = (buf2[pos+1]+buf1[fftsize+pos+1])/sw;



buf0[pos] = w1*spl0;
buf0[pos+1] = w1*spl1;
buf1[fftsize+pos] = w2*spl0;
buf1[fftsize+pos+1] = w2*spl1;

//more stuff for 2nd input
buf2[pos] = w1*spl2;
// buf2[pos+1] = w1*spl3;
buf3[fftsize+pos] = w2*spl2;
// buf3[fftsize+pos+1] = w2*spl3;

//buffer the original spl0
out4 = buf4[pos2]  ;
out5 = buf5[pos2];

buf4[pos2] =  spl0;
buf5[pos2] =  spl1;




// spl4=out4;
// spl5=out5;

spl0 = out0;
spl1 = out1;

spl2= out2;

//subtract front from original spl0 to get back
spl4=out4-out0-(h_sqrt_2*out2);
spl5=out5-out1-(h_sqrt_2*out2);


pos += 2;
pos2=(pos2+1)%(fftsize*1);


do_width(width_coeff);
do_depth(depth_coeff);
do_cross_width(R_width_coeff);

// @gfx 500 16

// box_width=8;

// gfx_a = 0.8; 
// drawbox(floor((pos/fftsize)*gfx_w),8);


@gfx 500 50

// box_width=8;
box_width=floor(0.7*sqrt((gfx_w+gfx_h)/2));

gfx_a = 0.2; 

// gfx_mode=1.0;

g=2;//counter for gfx

while
( 
	set_color(g/(fftsize/2.5)); //update color according to frequency
	gfx_a = min(sqrt(Magnitudes1[g]),1); //set alpha to magnitude , a >1 looks weird
	drawbox(Angle_Difference[g]*gfx_w/pi,gfx_h-g*gfx_h/(fftsize/2) ); //draw position for each bin
	// g=ceil(g^1.2);
	g+=8;
	g<fftsize/2 - 1;

);