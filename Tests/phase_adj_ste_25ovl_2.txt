//from https://forum.cockos.com/showthread.php?t=190168#30 by Tale

desc:FFT example
slider1:-3<-72.0,24.0,0.1>Gain (dB)
slider2:0<-180,180,1>Offset (deg)
slider3:0<0,1,1{25%,50%}>Overlap

@init

fftsize = 4096;
scale = 1/fftsize;

pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = fftsize - 1;

sixteen_k=32768;

trapezium = sixteen_k*1;
hann		= sixteen_k*2;
in_buf		= sixteen_k*3;
fft_buf		= sixteen_k*4;
out_buf		= sixteen_k*5;
pi=3.141592653589793238;
Angle_Difference=sixteen_k*41;
Angle_Difference_old=sixteen_k*42;
Fixed_Response=0.5;

i = 0;
loop(fftsize,
  trapezium[i] = min(2 - abs(4*i / fftsize - 2), 1); // Trapezium window
  hann[i] = 0.5 * (1 - cos(2*pi * i / fftsize)); // Hann window
  i += 1;
);

pos=0;


/*
w1 = window[pos/2];
w2 = window[(fftsize*1.5-pos)/2-1];
sw = (w1+w2)*fftsize;

out0 = (buf0[pos]+  buf1[fftsize*1.5+pos])/sw;
out1 = (buf0[pos+1]+buf1[fftsize*1.5+pos+1])/sw;

spl4=buf0[pos]/fftsize;
spl5=buf1[fftsize*1.5+pos]/fftsize;

buf0[pos] = w1*spl0;
buf0[pos+1] = w1*spl1;
buf1[fftsize*1.5+pos] = w2*spl0;
buf1[fftsize*1.5+pos+1] = w2*spl1;
*/

@slider

gain = 10^(slider1 / 20);
offset = 2*pi / 360 * slider2;

window = slider3 < 0.5 ? trapezium : hann;
overlap = floor(fftsize * (window == trapezium ? 0.25 : 0.5));

@sample

// Buffer input
in_buf[2*overlap + pos] = spl0 * scale;
in_buf[2*overlap + pos+1] = spl1 * scale;
(pos += 2) >= (fftsize - overlap )*2? (
  pos = 0;

  // Apply window
  i = 0;
  loop(fftsize,
    fft_buf[i] = in_buf[i] * window[i/2];
    fft_buf[i + 1] = in_buf[i+1] * window[i/2];
	// fft_buf[i + 1] = 0;

    i += 2;
  );

  // Overlap input
  memcpy(in_buf, in_buf + fftsize*2 - overlap*2, overlap*2);

  // FFT
  fft(fft_buf, fftsize);
  fft_permute(fft_buf, fftsize);

  // Adjust gain/phase
  i = 0;
  loop(fftsize / 2 + 1,
  
  
  // abs();
  		a = i;
		b = a+1;
		a2 = 2*fftsize-i;
		b2 = a2+1;
 

		x =  fft_buf[a];
		y =  fft_buf[b];
		x2 = fft_buf[a2];
		y2 = fft_buf[b2];

		 left_r = (x + x2)*0.5*gain;
		 left_i = (y - y2)*0.5*gain;
		right_r = (y + y2)*0.5*gain;
		right_i = (x2 - x)*0.5*gain;
		
		//use CPU to simulate a bigger FX
		test=atan2(sin(rand(1)),cos(rand(1)));
		test=atan2(sin(rand(1)),cos(rand(1)));
		test=atan2(sin(rand(1)),cos(rand(1)));
		
		
		an1=atan2(left_r,left_i); //radians, normalize to 0,2pi
		an2=atan2(right_r,right_i);	
		Angle_Difference[i]=abs(an1-an2);	

		// ad=Angle_Difference[i];
		Angle_Difference[i]>pi?Angle_Difference[i]=2*pi-Angle_Difference[i];//fix angle difference cuz should be under 180*
		
		Angle_Difference[i]=Angle_Difference[i]*(Fixed_Response)+Angle_Difference_old[i]*(1-Fixed_Response);
		Angle_Difference_old[i]=Angle_Difference[i];

		
		P_scaling=1;
		Angle_Difference[i]<pi*0.5?P_scaling=0;
		
		// P_scaling=Angle_Difference/pi;
		
		 left_r*=P_scaling;
		 left_i*=P_scaling;
		right_r*=P_scaling;
		right_i*=P_scaling;
		
		
		

		fft_buf[a]  = left_r - right_i;
		fft_buf[b]  = left_i + right_r;
		fft_buf[a2] = left_r + right_i;
		fft_buf[b2] = right_r - left_i;


    i += 2;
  );

  // Inverse FFT
  fft_ipermute(fft_buf, fftsize);
  ifft(fft_buf, fftsize);

  // Overlap-add output
  memcpy(out_buf, out_buf + 2*fftsize - 2*overlap, 2*overlap);
  memset(out_buf + 2*overlap, 0, 2*fftsize - 2*overlap);
  i = 0;
  loop(fftsize,
    out_buf[i] += fft_buf[i];
    out_buf[i+1] += fft_buf[i+1];
    i += 2;
  );
);

spl0 = out_buf[pos];
spl1 = out_buf[pos+1];