// from https://forum.cockos.com/showthread.php?t=190168#30 by Tale

desc:FFT example with 12.5% ovl
slider1:100<0,200,1>Amt
slider2:0<-180,180,1>Offset (deg)
slider3:40<0,50,5>Overlap

@init

fftsize = 4096;
scale = 1/fftsize;

pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = fftsize - 1;

sixteen_k=32768;

trapezium = sixteen_k*1;
hann		= sixteen_k*2;
in_buf		= sixteen_k*3;
fft_buf		= sixteen_k*4;
out_buf		= sixteen_k*5;
overlap_sel		= sixteen_k*9;
pi=3.141592653589793238;
Angle_Difference=sixteen_k*41;
Angle_Difference_old=sixteen_k*42;
Fixed_Response=0.5;
Magnitudes1=sixteen_k*11;
Magnitudes2=sixteen_k*12;
Magnitudes3=sixteen_k*13;
Magnitudes4=sixteen_k*14;

Magnitudes1_old=sixteen_k*21;
Magnitudes2_old=sixteen_k*22;
Magnitudes3_old=sixteen_k*23;
Magnitudes4_old=sixteen_k*24;

L_scaling_array=sixteen_k*31;
L_scaling_old_array=sixteen_k*32;


overlap_sel[0]=0.0625;		// 1/16
overlap_sel[1]=0.125;		// 1/8
overlap_sel[2]=0.25;		// 1/4
overlap_sel[3]=0.3125;		// 5/16 or 1/3.2
overlap_sel[4]=0.390625;	// 25/64 or 1/2.56
overlap_sel[5]=0.5;			// 1/2
overlap_w=overlap=0;


pos=0;


/*
w1 = window[pos/2];
w2 = window[(fftsize*1.5-pos)/2-1];
sw = (w1+w2)*fftsize;

out0 = (buf0[pos]+	buf1[fftsize*1.5+pos])/sw;
out1 = (buf0[pos+1]+buf1[fftsize*1.5+pos+1])/sw;

spl4=buf0[pos]/fftsize;
spl5=buf1[fftsize*1.5+pos]/fftsize;

buf0[pos] = w1*spl0;
buf0[pos+1] = w1*spl1;
buf1[fftsize*1.5+pos] = w2*spl0;
buf1[fftsize*1.5+pos+1] = w2*spl1;
*/

@slider
inspector1=floor(slider3/10);
overlap_w=overlap_sel[floor(slider3/10)];
// overlap_w=slider3/100;
overlap=floor(overlap_w*fftsize);
i = 0;
loop(fftsize,
	window[i] = min( (0.5 /overlap_w) - abs( (1/overlap_w) *i / fftsize -(0.5/overlap_w)), 1); // 39% ovl Trapezium window
// window[i] = min(1 - abs(2*i / fftsize -1), 1);
	i += 1;
);

// gain = 10^(slider1 / 20);
offset = 2*pi / 360 * slider2;

Amount=slider1/100;

// window = slider3 < 0.5 ? trapezium : hann;
// window =  trapezium ;
// overlap = floor(fftsize * (window == trapezium ? 0.25 : 0.5));


@sample

// Buffer input
in_buf[2*overlap + pos] = spl0 * scale;
in_buf[2*overlap + pos+1] = spl1 * scale;
(pos += 2) >= (fftsize - overlap )*2? (
	pos = 0;

	// Apply window
	i = 0;
	loop(fftsize,
		fft_buf[i] = in_buf[i] * window[i/2];
		fft_buf[i + 1] = in_buf[i+1] * window[i/2];
	// fft_buf[i + 1] = 0;

		i += 2;
	);

	// Overlap input
	memcpy(in_buf, in_buf + fftsize*2 - overlap*2, overlap*2);

	// FFT
	fft(fft_buf, fftsize);
	fft_permute(fft_buf, fftsize);

	// Adjust gain/phase
	i = 0;
	loop(fftsize / 2 + 1,
	
	
	// abs();
		a = i;
		b = a+1;
		a2 = 2*fftsize-i;
		b2 = a2+1;
 

		x =	fft_buf[a];
		y =	fft_buf[b];
		x2 = fft_buf[a2];
		y2 = fft_buf[b2];

		 left_r = (x + x2)*0.5;
		 left_i = (y - y2)*0.5;
		right_r = (y + y2)*0.5;
		right_i = (x2 - x)*0.5;
		Magnitudes1[i]=sqrt(left_r^2+left_i^2); //+very_small_number*0.1
		Magnitudes2[i]=sqrt(right_r^2+right_i^2);
		
		//use CPU to simulate a bigger FX
		test=atan2(sin(rand(1)),cos(rand(1)));
		// test=atan2(sin(rand(1)),cos(rand(1)));
		// test=atan2(sin(rand(1)),cos(rand(1)));
		
		
		an1=atan2(left_r,left_i); //radians, normalize to 0,2pi
		an2=atan2(right_r,right_i);	
		Angle_Difference[i]=abs(an1-an2);	
		
		// ad=Angle_Difference[i];
		Angle_Difference[i]>pi?Angle_Difference[i]=2*pi-Angle_Difference[i];//fix angle difference cuz should be under 180*
		
		Angle_Difference[i]=Angle_Difference[i]*(Fixed_Response)+Angle_Difference_old[i]*(1-Fixed_Response);
		Angle_Difference_old[i]=Angle_Difference[i];

		
		// P_scaling=1;
		// Angle_Difference[i]<pi*0.5?P_scaling=0;
		
		// P_scaling=Angle_Difference/pi;
		
		
		Rear_threshold=pi/2;
		Crossover_width=pi/2.5;
		
		P_scaling= 1-min(max( ( 1-(Angle_Difference[i]-Rear_threshold+(Crossover_width/2))*1*(1/Crossover_width) )   ,0)     ,1)  ;
		
		
		/*
			L_scaling_array[i]=max(Magnitudes1[i]-Magnitudes2[i]*Amount,0)/Magnitudes1[i];
			
			i<(fftsize/3) && L_scaling_array[i] < L_scaling_old_array[i]? 
			(
				L_scaling=L_scaling_array[i]*(0.5)+L_scaling_old_array[i]*(1-0.5);
			)
			:
			(	//equivalent to response of 1
				L_scaling =L_scaling_array[i];
			);
			
			L_scaling_old_array[i]=L_scaling_array[i]*(0.5)+L_scaling_old_array[i]*(1-0.5);
	// P_scaling=L_scaling;
	
	*/
		
		
	
		
		 left_r*=P_scaling;
		 left_i*=P_scaling;
		right_r*=P_scaling;
		right_i*=P_scaling;
		
		
		

		fft_buf[a]	= left_r - right_i;
		fft_buf[b]	= left_i + right_r;
		fft_buf[a2] = left_r + right_i;
		fft_buf[b2] = right_r - left_i;


		i += 2;
	);

	// Inverse FFT
	fft_ipermute(fft_buf, fftsize);
	ifft(fft_buf, fftsize);

	// Overlap-add output
	memcpy(out_buf, out_buf + 2*fftsize - 2*overlap, 2*overlap);
	memset(out_buf + 2*overlap, 0, 2*fftsize - 2*overlap);
	i = 0;
	loop(fftsize,
		out_buf[i] += fft_buf[i];
		out_buf[i+1] += fft_buf[i+1];
		i += 2;
	);
);

spl0 = out_buf[pos];
spl1 = out_buf[pos+1];