desc: mono to 15.1 panner. (phantom center) ALPHA.

slider1:0<-180,180>the pan (deg)
slider2:0<-100,100,5>Height (+ve up, -ve down)
slider3:100<0,100,5>width (+ve up, -ve down)
slider4:0<-100,100,5>Center (+ve up, -ve down)

slider5:0<0,3,{Move (Mixing),Copy (Mixing),Move (Monitoring),Copy (Monitoring)}>LFE Mode
slider6:0<0,100,1>LFE Amount(%)
slider7:1<0,1,{2D,3D}>Pan mode
slider8:8<0,8,1>pan threshold


import surroundlib1.txt

import surroundlib2.txt
import surroundlib3.txt

@init
pan_x=gfx_w/2;
pan_y=0;
theta=rad=0;

box_width=16;

polarity=1;

function drawbox(x,y)
(
	gfx_x=x-box_width/2;
	gfx_y=y-box_width/2;
	gfx_rectto(x+box_width/2,y+box_width/2)
);

//LFE
LFE_mode_gain=1;//monitoring 0dB default;
main_gain=1;
coeff_A=0;
coeff_B=0;



@slider
ELL_W=slider3/100   ;
top_W=slider3/100   ;

//LFE stuff
LFE_pan_coeff=(slider6*$pi)/200; //depth scaled from 0-100 to 0>half pi
calculate_depth_coeffs(LFE_pan_coeff);

//move or copy mode
slider5%2==0?(main_gain=coeff_B):(main_gain=1;);

//LFE mixing -10dB gain, LFE monitoring 0dB gain.
slider5<2?(LFE_mode_gain=0.316):(LFE_mode_gain=1;);


@sample 
in0=(spl0+spl1)*0.7071; //loudness compensation



do_10_to_71_pan(in0);
do_71_to_151_pan(slider2);

//top width for top panning
MS_encode_ELL();

//MS decode ELL
spl0=(front_M)+ (front_S * ELL_W) ;
spl1=(front_M)- (front_S * ELL_W) ;
spl4=(back_M )+ (back_S  * ELL_W) ;
spl5=(back_M )- (back_S  * ELL_W) ;
spl6=(side_M )+ (side_S  * ELL_W) ;
spl7=(side_M )- (side_S  * ELL_W) ;

//need top first otherwise bottom gets silenced, convert top to M/S
 MS_encode_Top();

//decode M/S with polarity
spl8 = ( (top_front_M)+ (top_front_S * top_W) ) ;
spl9 = ( (top_front_M)- (top_front_S * top_W) ) ;
spl12= ( (top_back_M )+ (top_back_S  * top_W) ) ;
spl13= ( (top_back_M )- (top_back_S  * top_W) ) ;
spl14= ( (top_side_M )+ (top_side_S  * top_W) ) ;
spl15= ( (top_side_M )- (top_side_S  * top_W) ) ;

//top depth bleed for top panning

spl14 +=    (spl8+spl12) * (100-slider3 )/100 ;
spl15 += (spl9+spl13) * (100-slider3 )/100 ;

spl8 *= slider3/100 ;
spl9 *= slider3/100 ;
spl12*= slider3/100 ;
spl13*= slider3/100 ;


//ell depth bleed for ell panning

spl16 += (spl0+spl4) * (100-slider3 )/100 ;
spl17 += (spl1+spl5) * (100-slider3 )/100 ;

spl0 *= slider3/100 ;
spl1 *= slider3/100 ;
spl4*= slider3/100 ;
spl5*= slider3/100 ;

//lfe
spl3=in0*LFE_mode_gain*coeff_A;
spl0=in0*main_gain;
spl1=in0*main_gain;

@gfx 500 500
pan=slider1;//pan, from clockwise, degrees
calculate_10_to_71_coeffs (pan);
calculate_71_to_151_coeffs_pc(slider2);
pan_thresh=slider8;

// draw box
// draw speaker

// convert rect polar
// convert polar rect 

gfx_a = 0.8;
gfx_r = gfx_g = gfx_b = 0;

gfx_x = 0; gfx_y = 0;

// v_w=min(gfx_w,gfx_h);
// v_h=v_w;


//draw ELL

//LR cyan
gfx_g =1;
gfx_b =1;
drawbox(gfx_w/3,0);
drawbox(gfx_w*2/3,0);

//Surround
gfx_b =0;
drawbox(gfx_w/3,gfx_h);
drawbox(gfx_w*2/3,gfx_h);

drawbox(0,gfx_h/2);
drawbox(gfx_w,gfx_h/2);

//draw height
gfx_g = gfx_b = 0;
gfx_r = 0.8;

height_toe_in=gfx_w/20;

drawbox(gfx_w/3+height_toe_in,gfx_h/3);
drawbox(gfx_w*2/3-height_toe_in,gfx_h/3);

//H S
drawbox(gfx_w/3+height_toe_in,gfx_h*2/3);
drawbox(gfx_w*2/3-height_toe_in,gfx_h*2/3);

drawbox(gfx_w/3-height_toe_in/2,gfx_h/2);
drawbox(gfx_w*2/3+height_toe_in/2,gfx_h/2);


(mouse_cap ==1 && mouse_x >=pan_x-box_width*pan_thresh && mouse_y >= pan_y -box_width*pan_thresh && mouse_x <=pan_x+box_width*pan_thresh && mouse_y <= pan_y +box_width*pan_thresh ) ? //if mouse is within threshold of pan knob
(
	gfx_x = mouse_x-box_width/2;
	gfx_y = mouse_y-box_width/2;


	;

	pan_x=mouse_x  ;
	pan_y=mouse_y ;	
	
	//compute numbers as if the origin was the center
	pan_x2=pan_x-gfx_w/2  ;
	pan_y2=-(pan_y-gfx_h/2);
	
	//convert to polar for pan
	theta = atan2(pan_y2,pan_x2);
	slider1=(theta*-180/$pi)+90;
	slider1>180?slider1=-180 + ( slider1-180 );
	
	rad=sqrt( (pan_x2^2+pan_y2^2 )/2);
	slider2=(110-(rad*100/( (gfx_w+gfx_h)/6) ))*1.5;
	
	slider2>100? //width to emulate top pan
	(
		slider3=min(100-(slider2-100)*1.5,100);
		slider2=100;



		
	):
	(
		slider3=100;//not top
	);
	
	 !(slider1<=30 && slider1>=-30)? (slider2=max(0,slider2) );// restrict bottom panning to front
	
	slider7==0?(slider2=0;);// restrict height panning to 3D
	
ELL_W=slider3/100   ;
top_W=slider3/100   ;

);



gfx_r = gfx_g = gfx_b = 1;
drawbox(pan_x,pan_y);

/*

gfx_rectto(x,y)
Fills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y.

gfx_rect(x,y,w,h) -- REAPER 4.59+
Fills a rectngle at x,y, w,h pixels in dimension.

gfx_setpixel(r,g,b)
Writes a pixel of r,g,b to gfx_x,gfx_y. 

gfx_r, gfx_g, gfx_b, gfx_a
These represent the current red, green, blue, and alpha components used by drawing operations (0.0..1.0). 

gfx_w, gfx_h
These are set to the current width and height of the UI framebuffer.

gfx_x, gfx_y
These set the "current" graphics position in x,y. You can set these yourselves, and many of the drawing functions update them as well.

gfx_mode
Set to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit().

gfx_clear
If set to a value greater than -1.0, this will result in the framebuffer being cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black). 

mouse_x, mouse_y
mouse_x and mouse_y are set to the coordinates of the mouse within the graphics area of the window.

mouse_cap
mouse_cap is a bitfield of mouse and keyboard modifier state.

    1: left mouse button 
*/