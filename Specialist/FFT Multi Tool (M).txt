desc: FFT Multi Tool. Read docs. in ALPHA
//tags: requested by James HE , modded by geraintluff, modded by junh1024,
//via https://forum.cockos.com/showpost.php?p=1962348&postcount=18

// TODO: performance improvements like moving FFT stuff to @block, frequency limiting

slider1:0<0,9,1{Max,Min (Denoise),Align (FPA),Subtract,Phase limit (unused),Phase reflect (unused),Gap filler 2,Sustainizer,Max2,Min2}>Mode
slider2:100<0,200,1>Amount
slider3:0.5<0,1,0.01>Response
slider4:2<0,4,1{1024,2048,4096,8192}>FFT Size


// import surroundlib3.txt

@init 

fftsize = -1;
pdc_bot_ch = 0;
pdc_top_ch = 4;

// array pointers
window=0;

sixteen_k=16384;


buf0 = sixteen_k*1;
buf1 = sixteen_k*2;

buf2 = sixteen_k*3;
buf3 = sixteen_k*4;

pos=0;

//my arrays for analysis
Magnitudes1=sixteen_k*5;
Magnitudes2=sixteen_k*6;
Magnitudes3=sixteen_k*7;
Magnitudes4=sixteen_k*8;
Magnitudes3_old=sixteen_k*9;
Magnitudes4_old=sixteen_k*10;


Angles1=sixteen_k*21;
Angles2=sixteen_k*22;
Angles3=sixteen_k*23;
Angles4=sixteen_k*24;

Angle_Difference=sixteen_k*31;

an3=an4=0;

old_magnitude=0;

gfx_r = gfx_g = gfx_b = 1;

mode=0;


L_scaling=R_scaling=0;
pi=3.141592653589793238;


@slider

sliderfft = (2^(slider4+10))|0;
fftsize != sliderfft ?
(
	pos = 0;
	memset(buf0, 0, 2*fftsize);
	memset(buf1, 0, 2*fftsize);
	memset(buf2, 0, 2*fftsize);
	memset(buf3, 0, 2*fftsize);
	memset(window, 0, fftsize);
	fftsize = sliderfft;
	w = 2.0*$pi/fftsize;
	i = 0;
	
	loop(fftsize/2,
		window[i] = 0.42-0.50*cos(i*w)+0.08*cos(2.0*i*w); //can make this a triangle?
		i += 1;
	); 
	pdc_delay = fftsize;
);




Amount=slider2/100;

mode=slider1+1;//cuz I don't like 0-based mode/slider

//V2 Re-Im modes sound different to original Ma-Ang modes

Response=slider3;


@sample

pos >= fftsize ?
(
	tmp = buf0;
	buf0 = buf1;
	buf1 = tmp;

	tmp = buf2;
	buf2 = buf3;
	buf3 = tmp;

	fft(buf0, fftsize);
	fft_permute(buf0, fftsize);

	fft(buf2, fftsize);
	fft_permute(buf2, fftsize);

	i = 2;
	loop(fftsize/2 - 1, 
		
		//loop indexes
		a = i;
		b = a+1;
		a2 = 2*fftsize-i;
		b2 = a2+1;


		//fft() works on complex numbers, but the input is real, so if you put only L in fft, it's wasteful. So they put L & R into Re & Imag to be more efficient. But you need to untangle it. Otherwise, use fft_real(). 

		x = buf0[a];
		y = buf0[b];
		x2 = buf0[a2];
		y2 = buf0[b2];

		real_l = (x + x2)*0.5;
		imag_l = (y - y2)*0.5;
		real_r = (y + y2)*0.5;
		imag_r = (x2 - x)*0.5;

		x_two = buf2[a];
		y_two = buf2[b];
		x2_two = buf2[a2];
		y2_two = buf2[b2];



		real_l_two = ( x_two + x2_two)*0.5;
		imag_l_two = ( y_two - y2_two)*0.5;
		real_r_two = ( y_two + y2_two)*0.5;
		imag_r_two = (x2_two -  x_two )*0.5;

		difference=real_l-real_l_two;//debug variable to make sure set1&2 are synchronized if they're the same

		//convert to polar. This is like, pythagoras trig stuff

		Magnitudes1[i]=sqrt(real_l^2+imag_l^2);
		Magnitudes2[i]=sqrt(real_r^2+imag_r^2);

		// Angles1[i]=atan2(real_l,imag_l)*180/$pi;
		// Angles2[i]=atan2(real_r,imag_r)*180/$pi;

		Magnitudes3[i]=sqrt(real_l_two^2+imag_l_two^2);
		Magnitudes4[i]=sqrt(real_r_two^2+imag_r_two^2);

		// Angles3[i]=atan2(real_l_two,imag_l_two)*180/$pi;
		// Angles4[i]=atan2(real_r_two,imag_r_two)*180/$pi;

		//TODO: HP ver - high performance ver in Re/Im
		
		//analyse the magnitudes, which one is biggest out of in1 & in2?

		(mode==1)? //Max mode
		(
			//independently test mags of L&R
			(Magnitudes1[i]<Magnitudes3[i])?
			(
			real_l=real_l_two;
			imag_l=imag_l_two;
			);
			
			(Magnitudes2[i]<Magnitudes4[i])?
			(
			real_r=real_r_two;
			imag_r=imag_r_two;
			);

		);
		
		(mode==2)? //Min mode
		(
			(Magnitudes1[i]>Magnitudes3[i])?
			(
			real_l=real_l_two;
			imag_l=imag_l_two;
			);
			
			(Magnitudes2[i]>Magnitudes4[i])?
			(
			real_r=real_r_two;
			imag_r=imag_r_two;
			);


		);

		(	//FPA mode, align only close magnitudes
			mode==3 &&
			abs(( Magnitudes1[i]-Magnitudes3[i])/ (Magnitudes1[i]+Magnitudes3[i] ))<Amount ;
		)
		? 
		(
			Angles3[i]=atan2(real_l_two,imag_l_two);
			Angles4[i]=atan2(real_r_two,imag_r_two);

			// Angle_Difference1[i]=Angles3[i]-Angles1[i];
			// Angle_Difference2[i]=Angles4[i]-Angles2[i];

			// Angles1[i]+=Angle_Difference1[i]*slider2/100;
			// Angles2[i]+=Angle_Difference2[i]*slider2/100;

			//just synthesize Re & Im with mag set1 & angles set2
			real_l = Magnitudes1[i]*sin(Angles3[i]) ;
			imag_l = Magnitudes1[i]*cos(Angles3[i]) ;
			real_r = Magnitudes2[i]*sin(Angles4[i]) ;
			imag_r = Magnitudes2[i]*cos(Angles4[i]) ;

		);

		mode==4? //subtract
		(
			//clamp mag to >0, otherwise will make more sound
			L_scaling=max(Magnitudes1[i]-Magnitudes3[i]*Amount,0)/Magnitudes1[i];
			R_scaling=max(Magnitudes2[i]-Magnitudes4[i]*Amount,0)/Magnitudes2[i];
			
			real_l *= L_scaling;
			imag_l *= L_scaling;
			real_r *= R_scaling;
			imag_r *= R_scaling;
		);
		
		(mode==7&&(Magnitudes1[i]+Magnitudes2[i])/2<old_magnitude)?// Gap filler
		(

			L_scaling=(old_magnitude*Amount)/Magnitudes1[i];
			R_scaling=(old_magnitude*Amount)/Magnitudes2[i];
			
			real_l *= L_scaling;
			imag_l *= L_scaling;
			real_r *= R_scaling;
			imag_r *= R_scaling;
			
			
			
			
			//Not completely correct cuz only analyzing L
		);
		
		old_magnitude=((Magnitudes1[i]+Magnitudes2[i])/2)*(Response/10)+old_magnitude*(1-Response/10);
		
		mode==8? // Sustainizer
		(

			
			// real_l*=(-1)^(i/2);
			// real_r*=(-1)^(i/2);
			// imag_l*=(-1)^i;
			// imag_r*=(-1)^i;
			
			rand1=ceil(rand(10));
			rand2=ceil(rand(10));
			
			real_l*=(-1)^rand1;
			real_r*=(-1)^rand1;
			imag_l*=(-1)^rand2;
			imag_r*=(-1)^rand2;
			
			
			
			// using=1;
			

			
			//TODO: HP ver phase by flipping Re Im  pseudo randomly
		);

		(mode==10)? //Min2
		(
			Angles1[i]=atan2(real_l,imag_l);
			Angles2[i]=atan2(real_r,imag_r);
			Angles3[i]=atan2(real_l_two,imag_l_two);
			Angles4[i]=atan2(real_r_two,imag_r_two);	
			
			//compute pans as per my V3 upmix
			p1=(Magnitudes3[i]-Magnitudes1[i])/(Magnitudes3[i]+Magnitudes1[i]);
			p2=(Magnitudes4[i]-Magnitudes2[i])/(Magnitudes4[i]+Magnitudes2[i]);
		//pan isn't that useful for dual stereo-different noise recordings, but useful for High Touch! (different singers on different versions)
		

			
			ad1=abs(Angles1[i]-Angles3[i]);
			ad2=abs(Angles2[i]-Angles4[i]);

			// an1=Angles1[i];
			// an2=Angles2[i];
			// an3=Angles3[i];
			// an4=Angles4[i];
			
			ad1>pi?ad1=2*pi-ad1;//fix angle difference cuz should be under 180*
			ad2>pi?ad2=2*pi-ad2; 

			L_scaling=(1-(min(ad1*2,pi)/pi))*(1-abs(p1));//double ad cuz 90* ad means it's already purely stereo noise
			R_scaling=(1-(min(ad2*2,pi)/pi))*(1-abs(p2));//Reduce mags the more it's panned & phased
			
			// Magnitudes1[i]*=L_scaling^Amount;//raised to power because doing linear multiple 1- is tricky
            // Magnitudes2[i]*=R_scaling^Amount;
			
			
			real_l *= L_scaling^Amount;
			imag_l *= L_scaling^Amount;
			real_r *= R_scaling^Amount;
			imag_r *= R_scaling^Amount;
			
			
			
			
			
			
		);  
		
		//TODO: center pan, generic de distort via harmonics, excite/pitchshift, denoise, transient designer, Tonal/noise separator, select notes via MIDI input
		
		
		// convert to cartesian
		//x=R cos (theta)


		x = real_l - imag_r;
		x2 = real_l + imag_r;
		y = imag_l + real_r;
		y2 = real_r - imag_l;

		buf0[a] = x;
		buf0[b] = y;
		buf0[a2] = x2;
		buf0[b2] = y2;

		i += 2
	);

	fft_ipermute(buf0, fftsize);
	ifft(buf0, fftsize);

	pos=0;
);

//windowing?
w1 = window[pos/2];
w2 = window[(fftsize-pos)/2-1];
sw = (w1+w2)*fftsize;

//i think this is FFT-size inverse scaling
out0 = (buf0[pos]+buf1[fftsize+pos])/sw;
out1 = (buf0[pos+1]+buf1[fftsize+pos+1])/sw;


// out2 = (buf2[pos]+buf1[fftsize+pos])/sw;
// out3 = (buf2[pos+1]+buf1[fftsize+pos+1])/sw;

buf0[pos] = w1*spl0;
buf0[pos+1] = w1*spl1;
buf1[fftsize+pos] = w2*spl0;
buf1[fftsize+pos+1] = w2*spl1;

//more stuff for 2nd input
buf2[pos] = w1*spl2;
buf2[pos+1] = w1*spl3;
buf3[fftsize+pos] = w2*spl2;
buf3[fftsize+pos+1] = w2*spl3;

spl0 = out0;
spl1 = out1;

spl2=spl3=0;//silence set2

pos += 2;

// @gfx 500 16

// box_width=8;

// gfx_a = 0.8; 
// drawbox(floor((pos/fftsize)*gfx_w),8);
